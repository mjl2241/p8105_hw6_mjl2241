---
title: "HW6"
output: github_document
editor_options: 
  chunk_output_type: console
---

This is my response to HW 6:

```{r setup, include=FALSE}
library(tidyverse)
library (patchwork)
library(readr)
library(broom)
library(viridis)
library(dbplyr)
library(MASS)
library(modelr)
library(mgcv)

knitr::opts_chunk$set(
	echo = TRUE,
	warning = FALSE,
	fig.width = 8, 
  fig.height = 6,
  out.width = "90%"
)

options(
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis"
)

scale_colour_discrete = scale_colour_viridis_d
scale_fill_discrete = scale_fill_viridis_d

theme_set(theme_minimal() + theme(legend.position = "bottom"))
```
### Problem 1
We start off by downloading the data from The Washing Post, on on homicides in 50 large U.S. cities via Github. After taking a look at the dataset, we also created city_state variable and a binary variable indicating whether the homicide is solved.
```{r}
homicide_df =
  read.csv(url("https://raw.githubusercontent.com/washingtonpost/data-homicides/master/homicide-data.csv")) %>%
  janitor::clean_names() 

skimr::skim(homicide_df)
  
homicide_df$city_state= 
  paste(homicide_df$city,",", homicide_df$state)

#drop certain cities
homicide_df = 
  homicide_df %>%
    filter(!(city_state %in% c("Dallas , TX", "Phoenix , AZ", "Kansas City , MO", "Tulsa , AL"))) %>% 
#drop rows not containing white or black in victim_race
  filter(victim_race == "White" | victim_race == "Black") %>%
#relevel the races
   mutate(
    victim_race=fct_relevel(victim_race, "White"),
#create a binary resolved variable
  resolved = as.numeric(disposition == 'Closed by arrest'), 
         victim_age=as.numeric(victim_age)) #change victim age as numeric
```
For the city of Baltimore, MD...  
``` {r baltimore}
baltimore_df = 
  homicide_df %>%
  filter(city == "Baltimore") %>%
  select(resolved, victim_age, victim_sex, victim_race)
```
using glm function to fit a logistic regression with resolved vs unresolved as the outcome and victim age, sex and race as predictors. 
``` {r create a logistic regression with glm function}
fit_logistic = 
  baltimore_df %>%
  glm(resolved ~victim_age + victim_race + victim_sex, data =.,
      family = binomial()) %>%
  broom::tidy()
```
Obtaining the estimate, OR, CI of OR for solving homicides comparing non-white victims to white victims keeping all other variables fixed:
```{r table}
fit_logistic %>%
  mutate(OR = exp(estimate)) %>%
#add CI
  group_by(term) %>%
  mutate(
    ci_lower = exp(estimate - std.error * 1.96),
    ci_upper =  exp(estimate + std.error * 1.96)) %>%
  select(term, log_OR = estimate, OR, ci_lower, ci_upper, p.value) %>% 
  knitr::kable(digits = 3)
```
Interpretation:
Homicides in which the victim is black are substantially less likely to be resolved that those in which the victim is white. Homicides in which the victim is male are significantly less like to be resolved than those in which the victim is female.The effect of age is statistically significant, and should be studied further.

Now run glm for each of the cities in your dataset, and extract the adjusted odds ratio (and CI) for solving homicides comparing Black victims to white victims. Do this within a “tidy” pipeline, making use of purrr::map, list columns, and unnest as necessary to create a dataframe with estimated ORs and CIs for each city.

``` {r}
glm_cities =
  homicide_df %>% 
  group_by(city_state) %>%
  select(city_state, resolved, victim_age, victim_sex, victim_race) %>%
  nest(data = -city_state) %>%
  mutate(
    models = map(data, ~glm(resolved ~victim_age + victim_race + victim_sex, data =.x, family = binomial)),
    results = map(models, broom::tidy)) %>% 
  select(-data, -models) %>% 
  unnest(results) %>%
#add CI, OR
  group_by(term) %>%
  mutate(
    ci_lower = exp(estimate - std.error * 1.96),
    ci_upper =  exp(estimate + std.error * 1.96),
    OR = exp(estimate)) %>%
  select(city_state, term, log_OR = estimate, OR, ci_lower, ci_upper, p.value) %>%
  filter(term == "victim_raceBlack") %>% 
  mutate(city_state = forcats::fct_reorder(factor(city_state), OR)) 
```
Create a plot that shows the estimated ORs and CIs for each city. Organize cities according to estimated OR, and comment on the plot.
``` {r plot for results_df}
glm_cities  %>% 
  ggplot(aes(x = city_state, y = OR)) +
  geom_point(size=5) + 
  geom_errorbar(aes(x=city_state, ymin = ci_lower, ymax = ci_upper)) +
  theme(text = element_text(size = 8), axis.text.x = element_text(angle = 60, hjust = 1)) + 
   #Add the title and the name for x and y axis. 
  labs(
    title = "OR estimation of unsolved black homicides by city, state",
    x = "City, State",
    y = "Estimation of OR of unsolved Black homicides"
  )
```
Based on the graph above, Boston, MA had the lowest odds ratio compared to other major cities, meanwhile,
Tampa, Florida had the highest odds ratio of unsolved black homicides. This graph illustrates the odds of solving homicides in 50 major cities significantly differ based on victim's race.

### Problem 2
Import data & load and clean the data for regression analysis 
``` {r import dataset}
bw=
  read.csv("./birthweight.csv") %>%
  janitor::clean_names() %>%
   mutate(babysex = as.factor(babysex),
          malform = as.factor(malform),
          mrace = as.factor(mrace),
          frace = as.factor(frace))
skimr::skim(bw)
```
For this dataset, babysex, malform, mrace, and frace were converted to factors. The dataset of child birth weight contains 20 columns and 4342 rows. 

I'll use stepwise to build a model for birthweight. 
```{r regression model}
# Fit the full model 
full.model <- lm(bwt ~., data = bw)
# Stepwise regression model
step.model = stepAIC(full.model, direction = "both", 
                      trace = FALSE)
```
The result indicated that 11 predictors, including babysex2 (female), bhead, blength, delwt, fincome, gaweeks, mheight, mrace2(black), mrace3(Asian), mrace4(Puerto Rian), parity, ppwt, and smoken were significant predictors. 
```{r}
#Final model:
final_model = 
  lm(bwt ~ babysex + bhead + blength + delwt + fincome + gaweeks + mheight + mrace + parity + ppwt + smoken, data = bw) 
final_model %>%
  broom::tidy ()
summary(final_model)
```
And now onto plotting of model residuals against fitted values – using add_predictions and add_residuals in making this plot.
```{r}
bw %>% 
  modelr::add_residuals(final_model) %>%
  modelr::add_predictions(final_model) %>%
  ggplot(aes(x = pred, y = resid)) + 
  geom_point() +
  labs(
    title = "Model Residuals v.s. Fitted Values",
    x = "Predicted values",
    y = "Residuals"
  )
```
#### About the model

I propose the above final model, based on stepwise regression selection. The variables seem reasonable predictors for babyweight, especially the baby gender, length, and gestational age(in weeks). The output shows that R^2 is 0.71, indicating that these 11 predictors (babysex2 (female), bhead, blength, delwt, fincome, gaweeks, mheight, mrace2(black), mrace3(Asian), mrace4(Puerto Rian), parity, ppwt, and smoken) explain 71% of the variance in birthweight. Based on the plot, we can see that when the prediction value is relatively small, the residual tend to be higher and the model does not have an accurate predication. When the prediction value is greater than 2000, the residuals become small and the prediction of the model is more accurate. This plot shows that the model violates the normal distribution of residual errors and homogeneity of residual variance.
```{r comparing to two others}
#other 3 models
model_2 = 
  lm(bwt ~ blength + gaweeks, data = bw) 
model_2%>%
  broom::tidy ()
model_3 = 
  lm(bwt ~ bhead*blength+babysex*blength +bhead*blength*babysex, data = bw) 
model_3%>%
  broom::tidy ()
```
#### Comparing models
```{r}
cv_df =
  crossv_mc(bw, 100) %>% 
  mutate(
    train = map(train, as_tibble),
    test = map(test, as_tibble))
cv_df = 
  cv_df %>% 
  mutate(
    final_model = map(train, ~lm(bwt ~ babysex + bhead + blength + delwt + fincome + gaweeks + mheight + mrace + parity + ppwt + smoken, data = bw)),
    model_2 = map(train, ~lm(bwt ~ blength + gaweeks, data = bw)),
    model_3 = map(train, ~lm(bwt ~ bhead*blength+babysex*blength +bhead*blength*babysex, data = bw))) %>% 
  mutate(
    rmse_final_model = map2_dbl(final_model, test, ~rmse(model = .x, data = .y)),
    rmse_model_2 = map2_dbl(model_2, test, ~rmse(model = .x, data = .y)),
    rmse_model_3 = map2_dbl(model_3, test, ~rmse(model = .x, data = .y))) 
```
#### plot the prediction error distribution
```{r}
cv_df %>% 
  select(starts_with("rmse")) %>%
  pivot_longer(
    everything(),
    names_to = "model", 
    values_to = "rmse",
    names_prefix = "rmse_") %>% 
  mutate(model = fct_inorder(model)) %>% 
  ggplot(aes(x = model, y = rmse)) + geom_violin()
```


